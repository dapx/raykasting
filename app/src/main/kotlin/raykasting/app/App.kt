/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package raykasting.app

import java.awt.Color
import java.awt.Graphics
import java.awt.Image
import java.awt.image.BufferStrategy
import java.awt.image.BufferedImage
import java.awt.image.DataBufferInt
import javax.swing.JFrame
import kotlin.concurrent.thread


fun main() {
    thread {
        val camera = Camera()
        val image = BufferedImage(640, 480, BufferedImage.TYPE_INT_RGB)
        val pixels = (image.raster.dataBuffer as DataBufferInt).data

        val textures = listOf(
            Texture(inputStream = Resources.readAsStream("planks.png"), 64),
            Texture(inputStream = Resources.readAsStream("brick.png"), 64),
            Texture(inputStream = Resources.readAsStream("ice.png"), 64),
            Texture(inputStream = Resources.readAsStream("stone.png"), 64)
        )

        val screen = Screen(map, textures, 640, 480)

        val window = JFrame("Example 3D Engine").apply {
            background = Color.BLACK
            isResizable = true
            setSize(640, 480)
            defaultCloseOperation = JFrame.EXIT_ON_CLOSE
            setLocationRelativeTo(null)
            isVisible = true
        }

        with(window) {
            addKeyListener(camera)
            run(image) {
                screen.update(camera, pixels)
                camera.update(map)
            }
        }
    }.join()
}

fun JFrame.render(image: BufferedImage) {
    val bufferStrategy: BufferStrategy = bufferStrategy ?: return createBufferStrategy(3)
    val graphics = bufferStrategy.drawGraphics
    graphics.drawImage(
        image = image,
        x = 0,
        y = 0,
        width = image.width,
        height = image.height
    )
    bufferStrategy.show()
}

fun JFrame.run(image: BufferedImage, execute: () -> Unit) {
    requestFocus()
    var lastTime = System.nanoTime()
    var executionWindowsOverTime = 0L

    loop {
        val now = System.nanoTime()
        executionWindowsOverTime += ((now - lastTime) / 60.timesPerSecond)
        lastTime = now
        while (executionWindowsOverTime >= 1.executions) {
            execute()
            executionWindowsOverTime--
        }
        render(image)
    }
}

fun loop(block: () -> Unit) {
    while (true) {
        block()
    }
}

fun Graphics.drawImage(image: Image, x: Int, y: Int, width: Int, height: Int): Boolean {
    return this.drawImage(image, x, y, width, height, null)
}

val Int.nanoSeconds: Long get() = this * 1_000_000_000L
val Int.timesPerSecond get() = 1.nanoSeconds / this
val Int.executions get() = toLong()

private val map = arrayOf(
    intArrayOf(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2),
    intArrayOf(1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2),
    intArrayOf(1, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2),
    intArrayOf(1, 0, 3, 0, 0, 0, 3, 0, 2, 0, 0, 0, 0, 0, 2),
    intArrayOf(1, 0, 3, 0, 0, 0, 3, 0, 2, 2, 2, 0, 2, 2, 2),
    intArrayOf(1, 0, 3, 0, 0, 0, 3, 0, 2, 0, 0, 0, 0, 0, 2),
    intArrayOf(1, 0, 3, 3, 0, 3, 3, 0, 2, 0, 0, 0, 0, 0, 2),
    intArrayOf(1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2),
    intArrayOf(1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 0, 4, 4, 4),
    intArrayOf(1, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 4),
    intArrayOf(1, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 4),
    intArrayOf(1, 0, 0, 2, 0, 0, 1, 4, 0, 3, 3, 3, 3, 0, 4),
    intArrayOf(1, 0, 0, 0, 0, 0, 1, 4, 0, 3, 3, 3, 3, 0, 4),
    intArrayOf(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4),
    intArrayOf(1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4)
)